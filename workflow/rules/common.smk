import os
from pathlib import Path
from threading import Lock
from typing import Iterable, Mapping

from snakemake.remote import AbstractRemoteProvider
from snakemake.utils import validate


#### Configuration ####
validate(config, schema="../schemas/config.schema.yml")  # also sets default values

#### Environment configuration ####
shell.prefix("set -o pipefail; ")


##### Helper functions #####

def create_remote_provider(remote_config: Mapping[str, str]) -> AbstractRemoteProvider:
    """
    Create a snakemake remote provider Based on the configured type.
    Returns None if the type is "local".
    """
    # LP: The snakemake.remote.AutoRemoteProvider seems like the ideal solution
    # for the problem of easily mapping a remote type to a concrete
    # RemoteProvider class.  However, as of snakemake v6.12.3 I was not able to
    # get it work.  So, we provide our own implementation here.
    import importlib

    ProviderMap = {
        "azblob": "AzBlob",
        "dropbox": "dropbox",
        "ega": "EGA",
        "ftp": "FTP",
        "gfal": "gfal",
        "gridftp": "gridftp",
        "gs": "GS",
        "http": "HTTP",
        "irods": "iRODS",
        "ncbi": "NCBI",
        "s3": "S3",
        "sftp": "SFTP",
        "webdav": "webdav",
        "xrootd": "XRootD",
    }

    remote_type = remote_config["type"].lower()
    if remote_type == "local":
        return None

    module_name = f"snakemake.remote.{ProviderMap[remote_type]}"
    provider_module = importlib.import_module(module_name)
    return provider_module.RemoteProvider(**remote_config["connection"])


# Create the remote providers.  If RProvider is None, then paths are local.
DestRProvider = create_remote_provider(config["destination"])
SourceRProvider = create_remote_provider(config["source"])


def _get_remote(remote_type: str, path: str) -> AbstractRemoteProvider:
    if remote_type not in ("source", "destination"):
        raise ValueError(f"Invalid remote_type '{remote_type}'. Expected 'source' or 'destination'")

    remote_config = config[remote_type]
    full_path = Path(remote_config["root_path"]) / path

    if remote_type == 'destination' and DestRProvider:
        return DestRProvider.remote(str(full_path), **remote_config["connection"])
    elif remote_type == 'source' and SourceRProvider:
        return SourceRProvider.remote(str(full_path), **remote_config["connection"])
    # else
    return full_path


def get_source_remote(path: str) -> AbstractRemoteProvider:
    return _get_remote('source', path)


def get_dest_remote(path: str) -> AbstractRemoteProvider:
    return _get_remote('destination', path)


def get_all_demangled_names() -> Iterable[str]:
    """
    Returns a list with all the decrypted data file names
    from the index generated by checkpoint rule decrypt_index.

    Can only be used in `input:` sections as it accesses checkpoints.
    """
    with checkpoints.decrypt_index.get().output.index.open() as f:
        return [line.split("\t", 2)[1] for line in f]


def _cache_index() -> None:
    class CacheItem:
        def __init__(self, plain_name, crypt_chksum):
            self.plain_name = plain_name
            self.crypt_chksum = crypt_chksum

    global _gRenameIndexCache  # defined in index.smk
    with _gRenameIndexLock:
        if _gRenameIndexCache is None:
            with checkpoints.decrypt_index.get().output.index.open() as f:
                # each line in the file is a tab-separated tuple (uuid4 name, original name, encrypted file checksum).
                tmp = dict()
                for line in f:
                    fields = line.rstrip("\n").split("\t")
                    tmp[fields[0]] = CacheItem(fields[1], fields[2])
            _gRenameIndexCache = tmp


def get_encrypted_item_checksum(encrypted_name: str) -> str:
    """
    Can only be used in `input:` sections as it accesses checkpoints.
    """
    _cache_index()
    global _gRenameIndexCache
    return _gRenameIndexCache[encrypted_name].crypt_chksum


def get_dest_item_names() -> Iterable[str]:
    # TODO: apply configured name filters
    def dest_name(old_name: str) -> str:
        # Remove the trailing .c4gh extension.  If the extension is not
        # .c4gh then we leave it. It can help make the workflow easier to adapt
        # to not-encrypted files.
        head, tail = os.path.splitext(old_name)
        return head if tail == '.c4gh' else old_name
 
    return [dest_name(p) for p in get_all_demangled_names()]



##### Module-level name index cache #####

# The file renaming index is produced in a file (by the rules in index.smk),
# but then we need to look it up as a the workflow DAG is computed.  Rather
# than having to read the entire file for each look-up, we cache it in the
# module-level variable _gRenameIndexCache defined below.
#
# I don't know whether it's thread safe to access a global structure like this
# in snakemake rules.  Since I'm in doubt we'll protect write accesses with a
# threading.Lock

_gRenameIndexLock = Lock()
_gRenameIndexCache = None
